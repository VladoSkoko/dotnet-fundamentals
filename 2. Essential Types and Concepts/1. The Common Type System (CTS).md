# The Common Type System (CTS)

.NET is designed to work with any programming language that can compile to the correct .NET assembly specifications. This allows for interoperability between different languages, enabling the use of libraries written in one language within applications written in another language. To achieve this multi-language support, Microsoft has defined standards and specifications. One of the key specifications is the Common Type System (CTS), which describes the data types supported by the runtime. The CTS ensures consistent type handling across different programming languages within the .NET framework.

In addition to CTS, there is also the Common Language Specification (CLS), which provides rules and constraints for creating libraries and components that can be used across multiple programming languages. The CLS is a subset of the CTS, meaning it adheres to the CTS standards while adding additional language interoperability guidelines. Furthermore, the .NET assembly specification defines the internal format of an assembly, ensuring a standardized structure for bytecode and metadata.

## Table of Contents

- [Primitive Types in CTS](#primitive-types-in-cts)
- [Custom Types and Type Categories](#custom-types-and-type-categories)
- [System.Object and Common Features](#systemobject-and-common-features)
- [Inheritance and Value Types vs. Reference Types](#inheritance-and-value-types-vs-reference-types)
- [Common Language Specification (CLS)](#common-language-specification-cls)
- [CLS Examples](#cls-examples)
- [.NET Assembly Specification](#net-assembly-specification)
- [Conclusion](#conclusion)

## Primitive Types in CTS <a name="primitive-types-in-cts"></a>

The Common Type System (CTS) encompasses a wide range of data types supported by the .NET runtime. Primitive types form the foundation of these data types and are directly handled by the computer's memory and CPU. They are built into the hardware, providing fast manipulation at nanosecond speeds. The .NET framework includes several primitive types that are part of the CTS, offering excellent performance due to their direct handling by the CPU hardware.

Here are the 12 primitive types specified in the CTS:

- `bool`: Represents a Boolean value (`true` or `false`).
- `byte` and `sbyte`: Hold eight-bit values.
- `char`: Stores Unicode characters.
- Integer types: 
  - `int`, `long`, `short`: Signed integers.
  - `uint`, `ulong`, `ushort`: Unsigned integers.
- Floating-point types:
  - `float`: 32-bit single precision.
  - `double`: 64-bit double precision.

These primitive types are valuable due to their high performance and are directly handled by the CPU hardware.

**Code Example:**

```csharp
// Example usage of primitive types
bool isTrue = true;
byte smallNumber = 42;
sbyte signedSmallNumber = -42;
char unicodeChar = 'A';
int integerNumber = 123;
long largeIntegerNumber = 1234567890;
uint unsignedInteger = 456;
ushort unsignedShort = 789;
float floatingPoint = 3.14f;
double doublePrecision = 2.71828;
```

## Custom Types and Type Categories <a name="custom-types-and-type-categories"></a>

While primitive types form the foundation of data types, a comprehensive framework like .NET needs to provide custom types as well. .NET defines different categories of types that encompass all available types in the framework. All code in .NET is implemented within a type, which can be classified into one of two groups: value types or reference types.

Most of the types created by the .NET team and other developers fall into the reference types category. However, the CTS supports the following five categories of types:

1. Value Types:
   - Structures: User-defined value types.
   - Enumerations: Enumerated values with underlying integral types.
2. Reference Types:
   - Classes: User-defined reference types.
   - Interfaces: Contracts defining member implementations for classes.
   - Delegates: Type-safe function pointers for callbacks.

When creating custom types in .NET, they will be based on one of these five categories. It's worth noting that all primitive types defined in .NET are structures.

## System.Object and Common Features <a name="systemobject-and-common-features"></a>

In .NET, all types, including both value types and reference types, derive from the `System.Object` base class. This inheritance allows all types to share common functionality and behavior provided by `System.Object`. The `System.Object` class defines several methods such as `ToString()`, `Equals()`, and `GetHashCode()`, which can be used when working with any type in the .NET framework.

Let's consider the following example. We have a method called `PrintCharCount` that takes an object parameter to accept any type. We create an instance of a value type (an integer) and an instance of a reference type (a string) and pass them to the method. We then use the `ToString()` method of `System.Object` to get the string representation of the passed instance.

```csharp
// Example demonstrating the usage of System.Object methods
void PrintCharCount(object obj)
{
    string objString = obj.ToString();
    int charCount = objString.Length;
    Console.WriteLine($"Character count: {charCount}");
}

int number = 7;
string text = "hello";

PrintCharCount(number); // Prints: Character count: 1
PrintCharCount(text);   // Prints: Character count: 5
```

Regardless of whether we pass a value type (integer) or a reference type (string), we can utilize `ToString()` and perform operations on the resulting string representation.

## Inheritance and Value Types vs. Reference Types <a name="inheritance-and-value-types-vs-reference-types"></a>

In .NET, there are differences in inheritance between value types and reference types. Value types can only inherit from `System.ValueType` or `System.Enum`, limiting the inheritance chain. On the other hand, reference types can inherit from other reference types, allowing for more complex inheritance hierarchies.

Let's examine an example where the `FileStream` class inherits from the `Stream` class. The `FileStream` class is a reference type that extends the functionality provided by the `Stream` class. In most cases, when the base class is not sealed, developers can create their own derived reference types.

```csharp
// Example demonstrating inheritance between reference types
class Stream { /* ... */ }
class FileStream : Stream { /* ... */ }

class CardStream : Stream { /* ... */ }  // Custom derived reference type

// Usage:
FileStream fileStream = new FileStream();
CardStream cardStream = new CardStream();
```

However, for value types, the inheritance options are limited. For example, a user-defined structure like `CardInfo` must inherit from a .NET type called `System.ValueType`. Similarly, an enumeration type like `CardFamilies` must inherit from `System.Enum`.

The .NET language (such as C#) provides support to ensure proper inheritance for value types and enumerations. By using the `struct` keyword in C# (as shown below), the C# compiler ensures that the structure inherits from `System.ValueType`. Similarly, the `enum` keyword guarantees that an enumeration inherits from `System.Enum`.

```csharp
// Example demonstrating value type and enumeration inheritance using C#
struct CardInfo { /* ... */ }

enum CardFamilies { /* ... */ }
```

The differences between value types and reference types go beyond inheritance and include aspects such as memory allocation and performance implications. While these topics are interesting, they are beyond the scope of this lesson, which focuses on the big picture of the Common Type System (CTS).

## Common Language Specification (CLS) <a name="common-language-specification-cls"></a>

The Common Language Specification (CLS) is a subset of the Common Type System (CTS) that defines a set of rules ensuring compiled code's usability in all .NET languages. As a programmer, you can write code in any .NET language (e.g., C#, F#, Visual Basic) targeting the .NET implementation and access types and members of class libraries without needing knowledge of the language in which they were originally written.

The CLS provides a standardized set of rules and conventions, enabling language interoperability within the .NET framework. It ensures that code written in different languages can seamlessly interact with each other.

For a comprehensive understanding of the constraints defined by the CLS, refer to the [Microsoft documentation](https://docs.microsoft.com/dotnet/standard/language-independence-and-language-independent-components).

## CLS Examples <a name="cls-examples"></a>

The CLS plays an important role in promoting language interoperability. Here are two examples that highlight CLS-related considerations:

1. Case Sensitivity: Some programming languages, like C#, are case-sensitive, while others, like Visual Basic, are not. In the following C# code example, two `CollectibleCard` classes are defined with only case differences. This difference in case wouldn't be distinguishable in Visual Basic, leading to a CLS-compliance issue. CLS-compliant compilers flag such errors, as indicated by the tooltip.

   ```csharp
   // Example demonstrating case sensitivity and CLS compliance
   class CollectibleCard { /* ... */ }
   class Collectiblecard { /* ... */ } // CLS-compliance issue (case-sensitive differentiation)

   // CLS-compliant compiler would flag the above error
   ```

2. Unsigned Integers: Some languages do not support unsigned integers. Therefore, using unsigned integers in code would not be CLS-compliant.

The CLS ensures that code adheres to a set of rules, making it usable across different .NET languages and preventing compatibility issues.

## .NET Assembly Specification <a name="net-assembly-specification"></a>

The .NET assembly specification defines the format in which a compiler must compile source code into a format called Common Intermediate Language (CIL) and store it in the assembly. Additionally, the compiler must create metadata tables describing all types from the code and the required library references.

All .NET assemblies follow a consistent internal structure for bytecode and metadata layout. The Common Language Runtime (CLR) utilizes the metadata tables to load any additional .NET assemblies required to run an application.

The .NET assembly specification ensures that assemblies have a standardized structure, enabling compatibility and seamless execution of .NET applications.

## Conclusion

The Common Type System (CTS) defines the data types supported by the .NET runtime, allowing for multi-language support. The Common Language Specification (CLS) adds language interoperability rules, and the .NET assembly specification defines the internal structure of assemblies. Understanding these concepts is essential for developing robust and interoperable .NET applications.
